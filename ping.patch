diff --git a/examples/companion_radio/MyMesh.cpp b/examples/companion_radio/MyMesh.cpp
index 9bb747e..63e778d 100644
--- a/examples/companion_radio/MyMesh.cpp
+++ b/examples/companion_radio/MyMesh.cpp
@@ -481,6 +481,31 @@ void MyMesh::sendFloodScoped(const mesh::GroupChannel& channel, mesh::Packet* pk
 void MyMesh::onMessageRecv(const ContactInfo &from, mesh::Packet *pkt, uint32_t sender_timestamp,
                            const char *text) {
   markConnectionActive(from); // in case this is from a server, and we have a connection
+  
+  // Check for ping message and reply with pong
+  if ((strcasecmp(text, "ping") == 0 || strcasecmp(text, "p") == 0) && strstr(getNodeName(), "ping") != NULL) {
+    // Get connection information
+    bool is_direct = (pkt->path_len == 0 || pkt->path_len == 0xFF);
+    int hop_count = is_direct ? 0 : pkt->path_len;
+    float snr = pkt->getSNR();
+    float rssi = _radio->getLastRSSI();
+    
+    // Create enhanced pong message with connection info
+    char pong_msg[64];
+    if (is_direct) {
+      snprintf(pong_msg, sizeof(pong_msg), "pong (direct, SNR: %.1fdB, RSSI: %.1fdB)", snr, rssi);
+    } else {
+      snprintf(pong_msg, sizeof(pong_msg), "pong (%d hops, SNR: %.1fdB, RSSI: %.1fdB)", hop_count, snr, rssi);
+    }
+    
+    // Send enhanced pong reply back to the sender
+    uint32_t expected_ack = 0;
+    uint32_t est_timeout = 0;
+    sendMessage(from, sender_timestamp, 0, pong_msg, expected_ack, est_timeout);
+    // Don't queue the ping message to keep chat history clean
+    return;
+  }
+  
   queueMessage(from, TXT_TYPE_PLAIN, pkt, sender_timestamp, NULL, 0, text);
 }
 
