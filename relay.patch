diff --git a/examples/companion_radio/MyMesh.cpp b/examples/companion_radio/MyMesh.cpp
index c80e286..aa7267e 100644
--- a/examples/companion_radio/MyMesh.cpp
+++ b/examples/companion_radio/MyMesh.cpp
@@ -2,6 +2,7 @@
 
 #include <Arduino.h> // needed for PlatformIO
 #include <Mesh.h>
+#include <string.h>
 
 #define CMD_APP_START                 1
 #define CMD_SEND_TXT_MSG              2
@@ -255,6 +256,34 @@ int MyMesh::calcRxDelay(float score, uint32_t air_time) const {
   return (int)((pow(_prefs.rx_delay_base, 0.85f - score) - 1.0) * air_time);
 }
 
+bool MyMesh::allowPacketForward(const mesh::Packet *packet) {
+  if (strstr(_prefs.node_name, "rptrl") != NULL) {
+    if (packet->isRouteFlood() && packet->path_len >= _prefs.flood_max) return false;
+    switch (packet->getPayloadType()) {
+      case PAYLOAD_TYPE_TXT_MSG:
+      case PAYLOAD_TYPE_GRP_TXT:
+      case PAYLOAD_TYPE_GRP_DATA:
+        return true;
+      default:
+        return false;
+    }
+  } else if (strstr(_prefs.node_name, "rptr") != NULL) {
+    if (packet->isRouteFlood() && packet->path_len >= _prefs.flood_max) return false;
+    return true;
+  } else {
+    return false;
+  }
+}
+
+uint32_t MyMesh::getRetransmitDelay(const mesh::Packet *packet) {
+  uint32_t t = (_radio->getEstAirtimeFor(packet->path_len + packet->payload_len + 2) * _prefs.tx_delay_factor);
+  return getRNG()->nextInt(0, 5*t + 1);
+}
+uint32_t MyMesh::getDirectRetransmitDelay(const mesh::Packet *packet) {
+  uint32_t t = (_radio->getEstAirtimeFor(packet->path_len + packet->payload_len + 2) * _prefs.direct_tx_delay_factor);
+  return getRNG()->nextInt(0, 5*t + 1);
+}
+
 uint8_t MyMesh::getExtraAckTransmitCount() const {
   return _prefs.multi_acks;
 }
@@ -801,6 +830,9 @@ MyMesh::MyMesh(mesh::Radio &radio, mesh::RNG &rng, mesh::RTCClock &rtc, SimpleMe
   _prefs.tx_power_dbm = LORA_TX_POWER;
   _prefs.gps_enabled = 0;       // GPS disabled by default
   _prefs.gps_interval = 0;      // No automatic GPS updates by default
+  _prefs.flood_max = 64;
+  _prefs.tx_delay_factor = 0.5f;
+  _prefs.direct_tx_delay_factor = 0.2f;
   //_prefs.rx_delay_base = 10.0f;  enable once new algo fixed
 }
 
diff --git a/examples/companion_radio/MyMesh.h b/examples/companion_radio/MyMesh.h
index a2b0033..d7a87aa 100644
--- a/examples/companion_radio/MyMesh.h
+++ b/examples/companion_radio/MyMesh.h
@@ -108,6 +108,9 @@ protected:
   int calcRxDelay(float score, uint32_t air_time) const override;
   uint8_t getExtraAckTransmitCount() const override;
   bool filterRecvFloodPacket(mesh::Packet* packet) override;
+  bool allowPacketForward(const mesh::Packet* packet) override;
+  uint32_t getRetransmitDelay(const mesh::Packet* packet) override;
+  uint32_t getDirectRetransmitDelay(const mesh::Packet* packet) override;
 
   void sendFloodScoped(const ContactInfo& recipient, mesh::Packet* pkt, uint32_t delay_millis=0) override;
   void sendFloodScoped(const mesh::GroupChannel& channel, mesh::Packet* pkt, uint32_t delay_millis=0) override;
diff --git a/examples/companion_radio/NodePrefs.h b/examples/companion_radio/NodePrefs.h
index 62cd416..30a6ab4 100644
--- a/examples/companion_radio/NodePrefs.h
+++ b/examples/companion_radio/NodePrefs.h
@@ -28,4 +28,7 @@ struct NodePrefs {  // persisted to file
   uint8_t  gps_enabled;      // GPS enabled flag (0=disabled, 1=enabled)
   uint32_t gps_interval;     // GPS read interval in seconds
   uint8_t autoadd_config;    // bitmask for auto-add contacts config
+  uint8_t  flood_max;
+  float    tx_delay_factor;
+  float    direct_tx_delay_factor;
 };
\ No newline at end of file
